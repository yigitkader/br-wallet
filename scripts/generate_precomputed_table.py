#!/usr/bin/env python3
"""
Generate precomputed G multiples table for secp256k1 scalar multiplication.

This creates a 64×16 table where:
  TABLE[window][idx] = idx * 2^(4*window) * G

For 256-bit scalars with 4-bit windows:
- 64 windows (256/4 = 64)
- 16 entries per window (0..15)
- Total: 1024 points

This eliminates runtime table computation and reduces doubles from 256 to 4!
"""

# secp256k1 curve parameters
P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
A = 0
B = 7
GX = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
GY = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8


def mod_inv(a, p):
    """Modular inverse using extended Euclidean algorithm."""
    if a == 0:
        return 0
    lm, hm = 1, 0
    low, high = a % p, p
    while low > 1:
        ratio = high // low
        nm, new = hm - lm * ratio, high - low * ratio
        lm, low, hm, high = nm, new, lm, low
    return lm % p


def point_add(p1, p2):
    """Add two points on secp256k1 curve."""
    if p1 is None:
        return p2
    if p2 is None:
        return p1
    
    x1, y1 = p1
    x2, y2 = p2
    
    if x1 == x2:
        if y1 != y2:
            return None  # Point at infinity
        # Point doubling
        s = (3 * x1 * x1) * mod_inv(2 * y1, P) % P
    else:
        s = (y2 - y1) * mod_inv(x2 - x1, P) % P
    
    x3 = (s * s - x1 - x2) % P
    y3 = (s * (x1 - x3) - y1) % P
    return (x3, y3)


def point_mul(k, point):
    """Scalar multiplication using double-and-add."""
    result = None
    addend = point
    
    while k:
        if k & 1:
            result = point_add(result, addend)
        addend = point_add(addend, addend)
        k >>= 1
    
    return result


def to_ulong4(value):
    """Convert 256-bit integer to ulong4 format (little-endian limbs)."""
    limbs = []
    for _ in range(4):
        limbs.append(value & 0xFFFFFFFFFFFFFFFF)
        value >>= 64
    return limbs


def format_ulong4(limbs):
    """Format ulong4 as Metal constant."""
    return f"{{0x{limbs[0]:016X}ULL, 0x{limbs[1]:016X}ULL, 0x{limbs[2]:016X}ULL, 0x{limbs[3]:016X}ULL}}"


def main():
    print("Generating precomputed table for secp256k1...")
    
    G = (GX, GY)
    
    # Generate base points for each window: 2^(4*w) * G
    window_bases = [None] * 64
    current = G
    for w in range(64):
        window_bases[w] = current
        # Multiply by 2^4 = 16 for next window
        for _ in range(4):
            current = point_add(current, current)
    
    # Generate table: TABLE[w][i] = i * window_bases[w]
    table_x = []
    table_y = []
    
    for w in range(64):
        base = window_bases[w]
        for i in range(16):
            if i == 0:
                # Point at infinity - use (0, 0) as marker
                table_x.append([0, 0, 0, 0])
                table_y.append([0, 0, 0, 0])
            else:
                point = point_mul(i, base)
                table_x.append(to_ulong4(point[0]))
                table_y.append(to_ulong4(point[1]))
    
    # Output Metal code
    output = []
    output.append("// ============================================================================")
    output.append("// PRECOMPUTED G MULTIPLES TABLE - Fixed-Base Comb Method")
    output.append("// ============================================================================")
    output.append("//")
    output.append("// TABLE[window][idx] = idx * 2^(4*window) * G")
    output.append("// 64 windows × 16 entries = 1024 points")
    output.append("//")
    output.append("// This eliminates runtime table computation and reduces:")
    output.append("//   - Runtime table generation: 14 EC adds → 0")
    output.append("//   - Doublings per scalar mul: 256 → 4")
    output.append("//   - Total EC ops: 334 → 68 (~5x speedup)")
    output.append("//")
    output.append("// Generated by scripts/generate_precomputed_table.py")
    output.append("// ============================================================================")
    output.append("")
    output.append("#include <metal_stdlib>")
    output.append("using namespace metal;")
    output.append("")
    output.append("#define PRECOMPUTED_WINDOWS 64")
    output.append("#define PRECOMPUTED_ENTRIES 16")
    output.append("")
    
    # X coordinates
    output.append("constant ulong4 PRECOMPUTED_GX[PRECOMPUTED_WINDOWS * PRECOMPUTED_ENTRIES] = {")
    for i, limbs in enumerate(table_x):
        comma = "," if i < len(table_x) - 1 else ""
        output.append(f"    {format_ulong4(limbs)}{comma}")
    output.append("};")
    output.append("")
    
    # Y coordinates
    output.append("constant ulong4 PRECOMPUTED_GY[PRECOMPUTED_WINDOWS * PRECOMPUTED_ENTRIES] = {")
    for i, limbs in enumerate(table_y):
        comma = "," if i < len(table_y) - 1 else ""
        output.append(f"    {format_ulong4(limbs)}{comma}")
    output.append("};")
    
    # Write to file
    with open("src/metal/precomputed_table.metal", "w") as f:
        f.write("\n".join(output))
    
    print(f"Generated {len(table_x)} points")
    print("Output: src/metal/precomputed_table.metal")
    
    # Verify first few points
    print("\nVerification:")
    print(f"G.x = 0x{GX:064X}")
    print(f"Table[0][1].x = 0x{table_x[1][3]:016X}{table_x[1][2]:016X}{table_x[1][1]:016X}{table_x[1][0]:016X}")
    
    # 2G
    g2 = point_add(G, G)
    print(f"2G.x = 0x{g2[0]:064X}")
    print(f"Table[0][2].x = 0x{table_x[2][3]:016X}{table_x[2][2]:016X}{table_x[2][1]:016X}{table_x[2][0]:016X}")


if __name__ == "__main__":
    main()

